深入理解计算机系统

137/726


p39	单指令，多数据并行，即SIMD并行
	图像处理，并行多对数据加法


p49-50	字0x01234567在大端法与小端法中的存储,高位字节为0x01,低位字节为0x67

最高有效字节在最前面:大端法
大端法	0x100	0x101	0x102	0x103	...
...	01	23	45	67	...

最低有效字节在最前面:小端法
小端法	0x100	0x101	0x102	0x103	...
...	67	45	23	01	...

p50	Intel IA32上反汇编(disassembler)而成
80483bd: 01 05 64 94 04 08 	add 	%eax, 0x8049464

p51	书写字节序列的自然方式是最低位字节在左边，而最高位字节在右边，这与通常书写书数字(高位在左，低位在右)时相反.


p55	~,&,|,^
~	~0=1; ~1=0	取反
&	0&0=0; 0&1=0; 1&0=0; 1&1=1	交集,且
|	0|0=0; 0|1=1; 1&0=1; 1|1=1	并集,或
^	0^0=0; 0^1=1; 1^0=1; 1^1=0	异或,相同为0,相反为1,XOR

p59	练习题2.15-只用位级和逻辑运算,编写一个C表达式,使其等价于(x==y).等价于,当x和y相等时它将返回1,否则返回0.(!x^y)

p60	逻辑右移,算术右移
参数x			[01100011] [10010101]
x << 4			[00110000] [01010000]
x >> 4(逻辑右移)	[00000110] [00001001]
x >> 4(算术右移)	[00000110] [11111001]

编译器对无符号数据,使用逻辑右移
编译器对有符号数据几乎都会使用算术右移,即填充对应的有效位,正数填充1,负数填充0
java中,x>>k(算术右移),x>>>k(逻辑右移)


数据表示:原码,反码,补码,反码,小数,整数,浮点数

定点小数:
原码,[X]原=X(0<=X<1);(1-X)(-1<X<=0)
	example: X=+0.1011, [X]原=01011;
		X=-0.1011, [X]原=11011
	[+0.0]原=00000, [-0.0]原=10000

补码,[X]补=X(0<=X<1);(2+X)mod2(-1<=X<=0)
	example: X=+0.1011, [X]补=01011;
		X=-0.1011, [X]补=2+X=10.0000+(-0.1011)=10101

反码,[X]反=X(0<=X<0);(2-2^(-n)+X)(-1<X<=0)
	example: X=+0.1011， [X]反=01011
		X=-0.1011， [X]反=10100
		[+0.0]反=00000,[-0.0]反=11111
	X= +0.1011, Y=-0.0100，有[X]反=01011, [Y]反=11011,
	[X+Y]反=[X]反+[Y]反=01011+11011=100110,最高位有进位,要加到结果的最低位,得00110+00001=00111,即+0.0111。


整数:
整数三种编码的定义、特性和相互间的变换方法，均与定点小数相应的三种表示类似，只是补码的取模值为2k+1 或2k+2 (对变形补码),这里的k为二进制整数数值位的位数。
example: X=+10101,[X]原=[X]补=[X]反=010101
	X=-10101,[X]原=110101,[X]补=101011,[X]反=101010
	以上两个数的变形补码分别为0010101和1101011。这里的K均为5。


浮点数:
M 		E 		M
1位		n+1位		m位
符号sign	阶码exponent	尾数significand
尾数部分M采用定点小数形式表示
尾数:1~2-#或0~1-#;#~0

单精度:
31	30-23	22-0
s	exp	frac

双精度:
63	62-52		51-32		31-0
s	exp		frac(51:32)	frac(31:0)

单精度:
1.规格化的
s	[!=0 & !=255]	f

2.未规格化的
s	[0000 0000]	f

3a.无穷大
s	[1111 1111]	[000...000]

3b.NaN
s	[1111 1111]	[!= 0]


移码:
最高一位为符号位,但其取值与原码和补码都相反,1代表正号,0代表负号.
	[X]移=2^n+X (-2^(-n)≤X<2^n)
整数补码:[X]补=X(0<=X<2^n);2^(n+1)+X(-2^n<=X<=0)

就可找出移码和补码之间的如下关系:
当0≤X<2^n时,[X]移=2^n+X=2^n+[X]补
当-2^n≤X<0时,[X]移=2^n+X=(2^(n+1)+X)-2^n

这表明,由 [X]补 得到 [X]移 的方法是变 [X]补 的符号为其反码。例如:
X = +1011， [X]补 = 01011， [X]移 = 11011
X = -1011， [X]补 = 10101， [X]移 = 00101


精通细节是理解更深和更基本概念的先决条件.



寻址

3类操作数-immediate,register,memory
immediate立即数-$0x1F or $-577
register寄存器-%eax or %ax-将寄存器组合看成一个数组R,用寄存器标识符作为索引.
E-R[Eb]-Eb为任意寄存器b
memory存储器-将寄存器看成一个很大的字节数组,Mb[Addr]表示对存储在存储器中从地址Addr开始的b个字节值的引用


Imm(Eb, Ei, s)=Imm + R[Eb] + R[Ei]*s  对应有效地址
Imm立即数偏移
Eb基址寄存器
Ei变址寄存器
s比例因子-1,2,4,8

操作数可以表示立即数,寄存器值或者来自存储器的值



